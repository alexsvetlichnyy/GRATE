
// Igor Pshenichnov 06.08.2008 + Alexandr Svetlichnyi 28.01.2019
// This main{} used to calculate de-excitation of hot nucleis
// by G4ExcitationHandler
// ROOT 5 or higher and Geant4 10 or higher installation is reqired

#include "G4RunManager.hh"
#include "G4StateManager.hh"

#include "G4ParticleTypes.hh"
#include "G4ParticleTable.hh"
#include "G4BosonConstructor.hh"
#include "G4LeptonConstructor.hh"
#include "G4MesonConstructor.hh"
#include "G4BaryonConstructor.hh"
#include "G4IonConstructor.hh"
#include "G4SystemOfUnits.hh"

#include "G4ReactionProductVector.hh"
#include "G4ReactionProduct.hh"
#include "G4ExcitationHandler.hh"
#include "G4NucleiProperties.hh"
#include "HandlerTestHistoManager.hh"
#include "TGlauberMC.hh"
#include "TGlauNucleon.hh"
#include "TGlauNucleus.hh"
#include "Randomize.hh"
#include "G4ParticleDefinition.hh"
#include "G4Threading.hh"

#include "G4UImanager.hh"
#include "G4IonTable.hh"
#include "G4Ions.hh"
#include "G4IonConstructor.hh"
#include "G4DeexPrecoParameters.hh"
#include "G4NuclearLevelData.hh"


 #include "TFile.h"
 #include "TH1D.h"
 #include "TH2D.h" 


int main()
{
   //Seting parameters for Deexcitation
  G4NuclearLevelData* fLevelData = G4NuclearLevelData::GetInstance(); 
  G4DeexPrecoParameters* fParam = fLevelData->GetParameters();
  fParam->SetMinExPerNucleounForMF(4*MeV);

  G4StateManager* fStateManager = G4StateManager::GetStateManager();

  
  G4RunManager * runManager = new G4RunManager;

  G4BosonConstructor pCBos;
  pCBos.ConstructParticle();
 
  G4LeptonConstructor pCLept;
  pCLept.ConstructParticle();

  G4MesonConstructor pCMes;
  pCMes.ConstructParticle();

  G4BaryonConstructor pCBar;
  pCBar.ConstructParticle();

  G4IonConstructor pCIon;
  pCIon.ConstructParticle();


  G4StateManager::GetStateManager()->SetNewState(G4State_Init); // To let create ions

  G4ParticleTable* partTable = G4ParticleTable::GetParticleTable();
  partTable->SetReadiness();

  
  //Defenition of level density functions
  
  G4double GaimardSchmidt(G4double, G4double, G4int ,G4int);

  G4double Ericson(G4double, G4double, G4int ,G4int);

  // The user will be asked for the charge and mass of the hot nuclear system to
  // simulate its decay. 

  HandlerTestHistoManager histoManager;

  // When thisTestVerbose > 0, the detailed information about each decay product is printed out  
  G4int thisTestVerbose = 1;


  // Histograms will be booked now.
  histoManager.BookHisto();

  //Open Prefragment Isotop Map
  histoManager.OpenHisto();
  TH2D * IsotopMap=(TH2D*) histoManager.GetIsotopMap();
  const G4double sigma=histoManager.GetIsotopMap()->Integral();
  G4int sourceA = histoManager.GetSourceA();
  G4int sourceZ = histoManager.GetSourceZ();
  

//Starting of dexcitation
  G4ExcitationHandler handler; 

  for(G4int count=0;count<100;count++){
  

//An event generated by GlauberMC should be here.
  G4float omega = -1;
  G4float signn = 42.2; //in mb

  TGlauberMC *mcg=new TGlauberMC("Pb","Pb",signn,omega);
  mcg->SetMinDistance(0);
  mcg->SetNodeDistance(0);
  mcg->SetCalcLength(0);
  mcg->SetCalcArea(0);
  mcg->SetCalcCore(0);
  mcg->SetDetail(99);
  TString om;
  if ((omega>=0) && (omega<=1)) {
    TF1 *f1 = getNNProf(signn, omega);
      mcg->SetNNProf(f1);
    om=Form("-om%.1f",omega);
  }
  mcg->Run(1);  

  G4int NpartA = mcg->GetNpartA();

  G4int A = sourceA - NpartA;
  G4int Z = G4int(A*(G4double(sourceZ)/G4double(sourceA)));

  G4double Ebound=40; //Maximum exitation energy per hole, MeV
  
  G4int N=1000; //Number of points at level density
  G4double ExcitationEnergyDistribution[N];
  //Excitation energy level density array creation
if(histoManager.GetStatType()<1.5){
   for(G4int n=0; n<N; n++){
     G4double s=Ericson(G4double(n)*((histoManager.GetUpEn()-histoManager.GetLowEn())/G4double(N)), Ebound, A, sourceA )*(histoManager.GetUpEn()-histoManager.GetLowEn())/N;
     ExcitationEnergyDistribution[n]=s;
   }
  }
else{
   for(G4int n=0; n<N; n++){
     ExcitationEnergyDistribution[n]=GaimardSchmidt(G4double(n)*((histoManager.GetUpEn()-histoManager.GetLowEn())/G4double(N)), Ebound, A, sourceA )*(histoManager.GetUpEn()-histoManager.GetLowEn())/N;
   }
}


  G4ThreeVector p3null(0.0,0.0,0.0);


  G4double totalNumFragments = 0.;
  G4int thisEventNumFragments = 0;
  
 
  std::cout.setf(std::ios::scientific,std::ios::floatfield);
  
  //Excitation energy computing
    CLHEP::RandGeneral randGeneral(ExcitationEnergyDistribution,N);
    CLHEP::RandGauss   randGauss(0,1);
	      
    G4double energy = 0;
    
    if(histoManager.GetStatType()<2.5){
     //Gaimard-Schmidt and Ericson distributions
      if(histoManager.GetStatType()>1.5  && A < 147 || histoManager.GetStatType()<1.5  && A < 0  ){energy = 8*(1+0.004*randGauss.shoot())*A;}
      else{
       energy = randGeneral.shoot()*(histoManager.GetUpEn()-histoManager.GetLowEn())+histoManager.GetLowEn();
      }    
    }
    else{
   //ALADIN parametrisation
     G4double e_0=8;//MeV
     G4double alpha = G4double(A)/G4double(sourceA);
     G4double sigma0 = 0.002;//should fit our results
     G4double c0 = 1.3; // From Bondorf 1995
     G4double sigma1 = randGauss.shoot()*sigma0*(1+c0*(1-alpha));
     G4double alpha1 = alpha + sigma1;
     energy = e_0*A*pow(1-alpha1 ,0.5);
    }
    

    histoManager.GetHisto2(1)->Fill(energy/G4double(A), G4double(A)/G4double(sourceA));

  G4double NuclearMass = G4NucleiProperties::GetNuclearMass(A,Z) + energy;
  G4LorentzVector p4(0.0,0.0,0.0,NuclearMass);
  G4Fragment aFragment(A,Z,p4);
                                                          
      G4ThreeVector p3cons;
      p3cons = p3null;
      G4double p3consMagnitude = 0.;

      G4int totCharge = 0;
      G4int totBarNumber =0;
      G4int RestFragmentZ=Z;
      G4int RestFragmentA=A;
	

      G4ReactionProductVector* theProduct = handler.BreakItUp(aFragment);

      thisEventNumFragments = theProduct->size();

      histoManager.GetHisto(2)->Fill(thisEventNumFragments);


      std::cout << "### event  at " << energy/A << " MeV/nucleon" 
      << " with "<< thisEventNumFragments <<" particles  #####\n";

      totalNumFragments += thisEventNumFragments;
       
      
      for (G4ReactionProductVector::iterator iVector = theProduct->begin(); iVector != theProduct->end(); ++iVector)
	{
          G4double thisFragmentZ = 0;
          G4double thisFragmentA = 0;
	  
	 const G4ParticleDefinition* pd = (*iVector)->GetDefinition();
	  
	  G4String particleEmitted =  pd->GetParticleName();
	  
         if ( particleEmitted != "gamma" ) {
	     thisFragmentZ = pd->GetAtomicNumber();
             thisFragmentA = pd->GetAtomicMass(); 
          }

	 RestFragmentZ=RestFragmentZ-thisFragmentZ;
	 RestFragmentA=RestFragmentA-thisFragmentA;

	  histoManager.GetHisto(6)->Fill(thisFragmentZ);
          if(thisEventNumFragments > 3){histoManager.GetHisto(8)->Fill(thisFragmentZ);}
          histoManager.GetHisto(7)->Fill(thisFragmentA);
	  histoManager.GetHisto2(2)->Fill(thisFragmentZ,thisFragmentA);
          delete (*iVector);
        }
 	  histoManager.GetHisto(6)->Fill(RestFragmentZ);
          histoManager.GetHisto(7)->Fill(RestFragmentA);
	  histoManager.GetHisto2(2)->Fill(RestFragmentZ,RestFragmentA);
          
      delete theProduct;
  }
  

  
       //histoManager.NormalizeHisto();
      histoManager.CleanHisto();
 

  delete runManager;
  return 0;
}

      
