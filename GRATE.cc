
// Igor Pshenichnov 06.08.2008 + Alexandr Svetlichnyi 28.01.2019
// This main{} used to calculate de-excitation of hot nucleis
// by G4ExcitationHandler
// ROOT 5 or higher and Geant4 10 or higher installation is reqired

#include "G4RunManager.hh"
#include "G4StateManager.hh"

#include "G4ParticleTypes.hh"
#include "G4ParticleTable.hh"
#include "G4BosonConstructor.hh"
#include "G4LeptonConstructor.hh"
#include "G4MesonConstructor.hh"
#include "G4BaryonConstructor.hh"
#include "G4IonConstructor.hh"
#include "G4SystemOfUnits.hh"

#include "G4ReactionProductVector.hh"
#include "G4ReactionProduct.hh"
#include "G4ExcitationHandler.hh"
#include "G4NucleiProperties.hh"
#include "HandlerTestHistoManager.hh"
#include "TGlauber/TGlauberMC.hh"
#include "TGlauber/TGlauNucleon.hh"
#include "TGlauber/TGlauNucleus.hh"
#include "Randomize.hh"
#include "G4ParticleDefinition.hh"
#include "G4Threading.hh"

#include "G4UImanager.hh"
#include "G4IonTable.hh"
#include "G4Ions.hh"
#include "G4IonConstructor.hh"
#include "G4DeexPrecoParameters.hh"
#include "G4NuclearLevelData.hh"


 #include "TFile.h"
 #include "TH1D.h"
 #include "TH2D.h" 


int main()
{
   //Seting parameters for Deexcitation
  G4NuclearLevelData* fLevelData = G4NuclearLevelData::GetInstance(); 
  G4DeexPrecoParameters* fParam = fLevelData->GetParameters();
  fParam->SetMinExPerNucleounForMF(3*MeV);

  G4StateManager* fStateManager = G4StateManager::GetStateManager();

  
  G4RunManager * runManager = new G4RunManager;

  G4BosonConstructor pCBos;
  pCBos.ConstructParticle();
 
  G4LeptonConstructor pCLept;
  pCLept.ConstructParticle();

  G4MesonConstructor pCMes;
  pCMes.ConstructParticle();

  G4BaryonConstructor pCBar;
  pCBar.ConstructParticle();

  G4IonConstructor pCIon;
  pCIon.ConstructParticle();


  G4StateManager::GetStateManager()->SetNewState(G4State_Init); // To let create ions

  G4ParticleTable* partTable = G4ParticleTable::GetParticleTable();
  partTable->SetReadiness();

  
  //Defenition of level density functions
  
  G4double GaimardSchmidt(G4double, G4double, G4int ,G4int);

  G4double Ericson(G4double, G4double, G4int ,G4int);

  // The user will be asked for the charge and mass of the hot nuclear system to
  // simulate its decay. 

  HandlerTestHistoManager histoManager;
 
  //arrays for tree creation
  std::vector<G4double> MassOnSideA;
  std::vector<G4double> MassOnSideB;
  G4int Npart_on_A;
  G4int Npart_on_B;
  G4double b;

  // Histograms will be booked now.
  histoManager.BookHisto();
  
  histoManager.GetTree()->Branch("A_on_A", "std::vector" ,&MassOnSideA);
  histoManager.GetTree()->Branch("A_on_B", "std::vector" ,&MassOnSideB);
  histoManager.GetTree()->Branch("Npart_on_A", &Npart_on_A,"Npart_on_A/I");
  histoManager.GetTree()->Branch("Npart_on_B", &Npart_on_B,"Npart_on_B/I");
  histoManager.GetTree()->Branch("impact_parameter", &b, "impact_parameter/D");
  
  //Get Z and A of nucleis
  G4int sourceA = histoManager.GetSourceA();
  G4int sourceZ = histoManager.GetSourceZ();
  

//Starting of modeling
//##################################################################################################################################
  G4ExcitationHandler handler; 

//Setting up Glauber code
 G4float omega = -1;
  G4float signn = 42.2; //in mb

  TGlauberMC *mcg=new TGlauberMC("Pb","Pb",signn,omega);
  mcg->SetMinDistance(0);
  mcg->SetNodeDistance(0);
  mcg->SetCalcLength(0);
  mcg->SetCalcArea(0);
  mcg->SetCalcCore(0);
  mcg->SetDetail(99);


  for(G4int count=0;count<histoManager.GetIterations() ;count++){
  

//An event generated by GlauberMC should be here.
  mcg->Run(1);  

  //Side A
  TGlauNucleus *nucA   = mcg->GetNucleusA(); 
  G4int NpartA = mcg->GetNpartA();
  b = mcg->GetB();
  Npart_on_A = NpartA;

  
  G4int A = nucA->GetN() - NpartA;
  G4int Z = G4int(A*(G4double(sourceZ)/G4double(sourceA)));

  G4double Ebound=40; //Maximum exitation energy per hole, MeV
  
  G4int N=1000; //Number of points at level density
  G4double ExcitationEnergyDistribution[N];
  //Excitation energy level density array creation
if(histoManager.GetStatType()<1.5){
   for(G4int n=0; n<N; n++){
     G4double s=Ericson(G4double(n)*((histoManager.GetUpEn()-histoManager.GetLowEn())/G4double(N)), Ebound, A, sourceA )*(histoManager.GetUpEn()-histoManager.GetLowEn())/N;
     ExcitationEnergyDistribution[n]=s;
   }
  }
else{
   for(G4int n=0; n<N; n++){
     ExcitationEnergyDistribution[n]=GaimardSchmidt(G4double(n)*((histoManager.GetUpEn()-histoManager.GetLowEn())/G4double(N)), Ebound, A, sourceA )*(histoManager.GetUpEn()-histoManager.GetLowEn())/N;
   }
}


  G4ThreeVector p3null(0.0,0.0,0.0);


  G4double totalNumFragments = 0.;
  G4int thisEventNumFragments = 0;
  
 
  std::cout.setf(std::ios::scientific,std::ios::floatfield);
  
  //Excitation energy computing
    CLHEP::RandGeneral randGeneral(ExcitationEnergyDistribution,N);
    CLHEP::RandGauss   randGauss(0,1);
	      
    G4double energy = 0;
    
    if(histoManager.GetStatType()<2.5){
     //Gaimard-Schmidt and Ericson distributions
      if(histoManager.GetStatType()>1.5  && A < 147 || histoManager.GetStatType()<1.5  && A < 0  ){energy = 8*(1+0.004*randGauss.shoot())*A;}
      else{
       energy = randGeneral.shoot()*(histoManager.GetUpEn()-histoManager.GetLowEn())+histoManager.GetLowEn();
      }    
    }
    else{
   //ALADIN parametrisation
     G4double e_0=8;//MeV
     G4double alpha = G4double(A)/G4double(sourceA);
     G4double sigma0 = 0.002;//should fit our results
     G4double c0 = 1.3; // From Bondorf 1995
     G4double sigma1 = randGauss.shoot()*sigma0*(1+c0*(1-alpha));
     G4double alpha1 = alpha + sigma1;
     energy = e_0*A*pow(1-alpha1 ,0.5);
    }
    

    histoManager.GetHisto2(1)->Fill(energy/G4double(A), G4double(A)/G4double(sourceA));

  G4double NuclearMass = G4NucleiProperties::GetNuclearMass(A,Z) + energy;
  G4LorentzVector p4(0.0,0.0,0.0,NuclearMass);
  G4Fragment aFragment(A,Z,p4);
                                                          
      G4ThreeVector p3cons;
      p3cons = p3null;
      G4double p3consMagnitude = 0.;

      G4int totCharge = 0;
      G4int totBarNumber =0;
      G4int RestFragmentZ=Z;
      G4int RestFragmentA=A;
	

      G4ReactionProductVector* theProduct = handler.BreakItUp(aFragment);

      thisEventNumFragments = theProduct->size();

      histoManager.GetHisto(2)->Fill(thisEventNumFragments);


      std::cout << "### event  at " << energy/A << " MeV/nucleon" 
      << " with "<< thisEventNumFragments <<" particles  #####\n";

      totalNumFragments += thisEventNumFragments;
       
      
      for (G4ReactionProductVector::iterator iVector = theProduct->begin(); iVector != theProduct->end(); ++iVector)
	{
          G4double thisFragmentZ = 0;
          G4double thisFragmentA = 0;
	  
	 const G4ParticleDefinition* pd = (*iVector)->GetDefinition();
	  
	  G4String particleEmitted =  pd->GetParticleName();
	  
         if ( particleEmitted != "gamma" ) {
	     thisFragmentZ = pd->GetAtomicNumber();
             thisFragmentA = pd->GetAtomicMass(); 
          }
         MassOnSideA.push_back(thisFragmentA);
         
	 RestFragmentZ=RestFragmentZ-thisFragmentZ;
	 RestFragmentA=RestFragmentA-thisFragmentA;
	 
    	  histoManager.GetHisto(6)->Fill(thisFragmentZ);
          if(thisEventNumFragments > 3){histoManager.GetHisto(8)->Fill(thisFragmentZ);}
          histoManager.GetHisto(7)->Fill(thisFragmentA);
	  histoManager.GetHisto2(2)->Fill(thisFragmentZ,thisFragmentA);
          delete (*iVector);
        }
	  MassOnSideA.push_back(RestFragmentA);
 	  histoManager.GetHisto(6)->Fill(RestFragmentZ);
          histoManager.GetHisto(7)->Fill(RestFragmentA);
	  histoManager.GetHisto2(2)->Fill(RestFragmentZ,RestFragmentA);
          
      delete theProduct;

//$$$$$$$$$$$$$$$//Side B//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
      TGlauNucleus *nucB   = mcg->GetNucleusB(); 
      G4int NpartB = mcg->GetNpartB();
      Npart_on_B = NpartB;
      
      
      G4int Ab = nucB->GetN() - NpartB;
      G4int Zb = G4int(Ab*(G4double(sourceZ)/G4double(sourceA)));
      histoManager.GetHisto2(3)->Fill(A,Ab);
	
         G4double energyB = 0;
	    
	    if(histoManager.GetStatType()<2.5){
	    //Gaimard-Schmidt and Ericson distributions
	       energyB = randGeneral.shoot()*(histoManager.GetUpEn()-histoManager.GetLowEn())+histoManager.GetLowEn();
	    }
	    else{
	   //ALADIN parametrisation
	     G4double e_0=8;//MeV
	     G4double alpha = G4double(A)/G4double(sourceA);
	     G4double sigma0 = 0.002;//should fit our results
	     G4double c0 = 1.3; // From Bondorf 1995
	     G4double sigma1 = randGauss.shoot()*sigma0*(1+c0*(1-alpha));
	     G4double alpha1 = alpha + sigma1;
	     energyB = e_0*A*pow(1-alpha1 ,0.5);
	    }
	
  G4double NuclearMassB = G4NucleiProperties::GetNuclearMass(Ab,Zb) + energyB;
  G4LorentzVector p4b(0.0,0.0,0.0,NuclearMassB);
  G4Fragment aFragmentB(Ab,Zb,p4);
                                                          
      G4ThreeVector p3consB;
      p3consB = p3null;
      G4double p3consMagnitudeB = 0.;

      G4int RestFragmentZb=Zb;
      G4int RestFragmentAb=Ab;
        

      G4ReactionProductVector* theProductB = handler.BreakItUp(aFragmentB);
      
      for (G4ReactionProductVector::iterator iVector = theProductB->begin(); iVector != theProductB->end(); ++iVector)
	{
          G4int thisFragmentZb = 0;
          G4int thisFragmentAb = 0;
	  
	 const G4ParticleDefinition* pdB = (*iVector)->GetDefinition();
	  
	 G4String particleEmittedB = pdB->GetParticleName();
	  
         if ( particleEmittedB != "gamma" ) {
	     thisFragmentZb = pdB->GetAtomicNumber();
             thisFragmentAb = pdB->GetAtomicMass(); 
          }
         MassOnSideB.push_back(thisFragmentAb);         

	 RestFragmentZb=RestFragmentZb-thisFragmentZb;
	 RestFragmentAb=RestFragmentAb-thisFragmentAb;
	 
    	  histoManager.GetHisto(6)->Fill(thisFragmentZb);
          if(thisEventNumFragments > 3){histoManager.GetHisto(8)->Fill(thisFragmentZb);}
          histoManager.GetHisto(7)->Fill(thisFragmentAb);
	  histoManager.GetHisto2(2)->Fill(thisFragmentZb,thisFragmentAb);
          delete (*iVector);
        }
	  MassOnSideB.push_back(RestFragmentAb);
 	  histoManager.GetHisto(6)->Fill(RestFragmentZb);
          histoManager.GetHisto(7)->Fill(RestFragmentAb);
	  histoManager.GetHisto2(2)->Fill(RestFragmentZb,RestFragmentAb);
          
      delete theProductB;      
 //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

  histoManager.GetTree()->Fill();
  MassOnSideA.clear();
  MassOnSideB.clear();  
  
  }
  

  
       //histoManager.NormalizeHisto();
      histoManager.CleanHisto();
 

  delete runManager;
  return 0;
}

      
